"""
<Program Name>
  reversegeo_blur.r2py

<Started>
  February 1, 2015

<Author>
  Aditi Prabhu

<Purpose>
 Gets the location details when the lat/long coordinates are given, 
 based on the precision (zoom level) specified by the user.

"""

# To-do:
# Check if arguments are of the correct type.
# In loc_parser, prevent wrong output when the required field 
# is not in Nominatim's database. -Using xmlparse.r2py and 
# Nominatim's zoom levels maybe? (json format - easier to parse)

def get_location_details(latitude, longitude, zoom):
 """
  <Purpose>
   Performs reverse geocoding and returns required 
   location information

  <Arguments>
   latitude
   longitude
   zoom - The required level of precision from the location data
     1: Country
     2: State
     3: City
     4: Road
     5: House Number

  <Returns>
   Location string
	"""

  message_to_server = build_GET_message(latitude, longitude)
  nominatim_server_connection = get_connection_to_geoip_server(gethostbyname("nominatim.openstreetmap.org"),80)
  nominatim_server_connection.send(message_to_server)
  message_from_server = get_response_from_geoip_server(nominatim_server_connection, 2) #timeout = 2
  nominatim_server_connection.close()
  location = loc_parser(message_from_server, zoom)
  return location


def build_GET_message(lat, long):
  message = "GET /reverse?format=xml&lat=" + str(lat) + "&lon=" + str(long) + \
  "&zoom=18&addressdetails=1 HTTP/1.1\r\nHost: nominatim.openstreetmap.org\r\n\r\n"
  return message


def get_connection_to_geoip_server(serverip,port_no):
  available_ports = list(getresources()[0]['connport']) #???
  
  for port in available_ports:
    port = int(port) 
    try:
      nominatim_server_connection = openconnection(serverip, \
        port_no, getmyip(), port, 5)		#timeout = 5
      log("Using port", port, "\n\n")
      return nominatim_server_connection
    except Exception as e:
      log("Using port", port, "had a problem:", str(e), '\n\n')
      continue

  raise Exception("No ports available.\n")


def get_response_from_geoip_server(nominatim_server_connection, timeout):
  received_string = ""
  time_started = getruntime()
  while getruntime() < time_started+timeout:
    try:
      received_string = nominatim_server_connection.recv(4096)
    except SocketWouldBlockError:
      if received_string != "":
        break
    except SocketClosedRemote:
      pass

  if received_string == "":
    raise Exception("Timed out.")
  else:
    return received_string


def loc_parser(message, zoom):

  if zoom == 1: #country
    start = message.find("<country>") + len("<country>")
    end = message.find("</country>")
    message = message[start:end] + "\n\n"
    return message

  if zoom == 2: #state
    start = message.find("<state>") + len("<state>")
    end = message.find("</state>")
    message = message[start:end] + ", " + loc_parser(message, 1)
    return message

  if zoom == 3: #city
    start = message.find("<city>") + len("<city>")
    end = message.find("</city>")
    message = message[start:end] + ", " + loc_parser(message, 2)
    return message

  if zoom == 4: #road
    start = message.find("<road>") + len("<road>")
    end = message.find("</road>")
    message = message[start:end] + ", " + loc_parser(message, 3)
    return message

  if zoom == 5: #house number
    start = message.find("<house_number>") + len("<house_number>")
    end = message.find("</house_number>")
    message = message[start:end] + ", " + loc_parser(message, 4)
    return message



# test
log(get_location_details(52.54877605, -1.81627023283164, 5))