"""
<Program Name>
  reversegeo_blur_json.r2py

<Started>
  February 1, 2015

<Author>
  Aditi Prabhu

<Purpose>
 This program uses the latitude and longitude data from the GPS and returns
 an address related to these coordinates. It can also return just the 
 coordinates if the "truncate" flag is set to be True. The "zoom" parameter
 for the address specifies the level of detail that must be present in the 
 address returned and blurs out everything else. The zoom value varies
 from 0-18, where 0 is country and 18 is the house/building.
 
 We use Nominatim to perform this. The wiki for this tool is available at 
 http://wiki.openstreetmap.org/wiki/Nominatim#Reverse_Geocoding_.2F_Address_lookup
 
 Note: If the Nominatim server is down, truncated GPS coordinates are returned.

"""

def get_address(latitude, longitude, zoom, truncate):
	"""
  <Purpose>
   This is the main function which performs reverse geocoding and returns
	 required level of detail from the address generated by the lat/long pair,
	 or returns the truncated GPS coordinates depending on the zoom level 
	 provided by the user.

  <Arguments>
   latitude:
	         (type: int, float) - the latitude coordinate returned by the GPS
   longitude:
	         (type: int, float) - the longitude coordinate returned by the GPS
   zoom:
	         (type: int from 0-18) - the required level of detail in the address
	 truncate:
	 				 (type: boolean) - set to True to return coordinates instead of address

	<Exceptions>
			TypeError if the input arguments are of the wrong type
	    PortsUnavailableError when there are no available ports
			TimeoutError when the connection times out before receiving any data

	<Returns>
   A string containing the blurred address or a dictionary containing the
	 latitutde and longitude coordinates

	"""

	# Type checking
	if isinstance(latitude, (int, float)) == False:
		raise TypeError(str(type(latitude)) + " is not a valid type for Latitude!\n\n")
	if isinstance(longitude, (int, float)) == False:
		raise TypeError(str(type(longitude)) + " is not a valid type for Longitude!\n\n")
	if isinstance(zoom, int) == False:
		raise TypeError(str(type(zoom)) + " is not a valid type for Zoom!\n\n")
	if isinstance(truncate, type(True)) == False:
		raise TypeError(str(type(truncate)) + " is not a valid type for Truncate!\n\n")

	if truncate == True:
		coordinates = truncate_coordinates(latitude, longitude, zoom)
		return coordinates

	message_to_server = build_GET_message(latitude, longitude, zoom)
	nominatim_server_connection = get_connection_to_geoip_server(gethostbyname("nominatim.openstreetmap.org"), 80)
	nominatim_server_connection.send(message_to_server) # Sends query to the Nominatim server
	message_from_server = get_response_from_geoip_server(nominatim_server_connection, 5) #timeout = 2
	nominatim_server_connection.close()
	location = json_parser(message_from_server, zoom)
	if location == -1: # If server is down, return the coordinates
		log("Server is down. Returning coordinates of the location...")
		coordinates = truncate_coordinates(latitude, longitude, zoom)
		return coordinates
	return location


def truncate_coordinates(lat, long, zoom):
	if zoom >= 15:
		return {"latitude":lat, "longitude":long}
	elif zoom >= 10:
		lat = "%.2f" % lat
		long = "%.2f" % long
		return {"latitude":lat, "longitude":long}
	elif zoom >= 5:
		lat = "%.1f" % lat
		long = "%.1f" % long
		return {"latitude":lat, "longitude":long}
	else:
		lat = "%.f" % lat
		long = "%.f" % long
		return {"latitude":lat, "longitude":long}


# Builds the HTTP GET message to be sent
def build_GET_message(lat, long, zoom):
	message = "GET /reverse?format=json&lat=" + str(lat) + "&lon=" + str(long) + \
	"&zoom=" + str(zoom) + "&addressdetails=1 HTTP/1.1\r\nHost: nominatim.openstreetmap.org\r\n\r\n"
	return message


# Connects to the Nominatim server from any available port
def get_connection_to_geoip_server(serverip, port_no):
	available_ports = list(getresources()[0]['connport']) #???
	  
	for port in available_ports:
		port = int(port) 
		try:
			nominatim_server_connection = openconnection(serverip, \
				port_no, getmyip(), port, 5)		#timeout = 5
			return nominatim_server_connection
		except Exception as e:
			log("Using port", port, "had a problem:", str(e), '\n\n')
			continue

	raise PortsUnavailableError("Sorry! No ports available at this time.\n\n")


# Receives the reply from the Nominatim server after the query is sent
def get_response_from_geoip_server(nominatim_server_connection, timeout):
	received_string = ""
	time_started = getruntime()
	while getruntime() < time_started+timeout:
		try:
			received_string = nominatim_server_connection.recv(4096)
		except SocketWouldBlockError:
			if received_string != "":
				break
		except SocketClosedRemote:
			pass

	if received_string == "":
		raise TimeoutError("Connection timed out.\n\n")
	else:
		return received_string


# Extract the required data from the reply sent by the 
# Nominatim server. The reply is a string that consists of
# the HTTP OK messaage and the address details in JSON 
# format. We need to extract the data from the field
# "display_name", which contains the address at th desired zoom
# level

def json_parser(message, zoom):

	# Get index of the first occurance of ' "display_name":" '
	start = message.find("\"display_name\":\"")
	if start == -1:
		return -1
	
	# Extract all data present after ' "display_name":" '
	message = message[(start + len("\"display_name\":\"")):]

	# Find the index of the next occurance of the double quote
	# which indicates the end of the diaplay_name field
	end = message.find("\"")

	# This will contain the required string
	message = message[:end] + "\n\n"
	
	return message



# test
log(get_address(52.54877605, -1.81627023283164, 12, True))
log("\n\n")

log(get_address(52.54877605, -1.81627023283164, 12, False))
log("\n\n")